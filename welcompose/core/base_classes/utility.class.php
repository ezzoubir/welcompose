<?php

/**
 * Project: Welcompose
 * File: utility.class.php
 * 
 * Copyright (c) 2008-2012 creatics, Olaf Gleba <og@welcompose.de>
 * 
 * Project owner:
 * creatics, Olaf Gleba
 * 50939 KÃ¶ln, Germany
 * http://www.creatics.de
 *
 * This file is licensed under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE v3
 * http://www.opensource.org/licenses/agpl-v3.html
 * $Id: utility.class.php 48 2007-01-19 15:49:28Z andreas $
 * 
 ** 
 * @author Andreas Ahlenstorf
 * @package Welcompose
 * @link http://welcompose.de
 * @license http://www.opensource.org/licenses/agpl-v3.html GNU AFFERO GENERAL PUBLIC LICENSE v3
 */

class Base_Utility {

	/**
	 * Reference to Smarty
	 *
	 * @var object
	 */
	public $smarty = null;
	
	/**
	 * Reference to PEAR::Date object
	 * 
	 * @var object
	 */
	public $date = null;
	
	/**
	 * Reference to PEAR::Date_Timezone object
	 * 
	 * @var object
	 */
	public $timezone = null;

/**
 * Smarty Import Function
 *
 * Function to import Smarty into the base class. This function
 * takes the full path to a smarty config file as first argument.
 * The config file should look (more or less) like Example 2-9 in 
 * the Smarty documentation:
 *
 * http://smarty.php.net/manual/en/installing.smarty.basic.php
 *
 * @param string Path to smarty configuration file
 */
public function loadSmarty ($conf)
{
	// input check
	if (empty($conf) || !is_scalar($conf)) {
		trigger_error("No path to Smarty configuration file supplied", E_USER_ERROR);
	}
	$conf = Base_Compat::fixDirectorySeparator($conf);
	if (!file_exists($conf) || !is_readable($conf)) {
		trigger_error("Smarty configuration file $conf not found", E_USER_ERROR);
	}	
	// load smarty class
	$file = dirname(__FILE__).'/../smarty/Smarty.class.php';
	$file = Base_Compat::fixDirectorySeparator($file);
	
	require_once($file);

	// create new smarty instance if none exists
	if (!($this->smarty instanceof Smarty)) {
		
		// create new smarty instance
		$smarty = new Smarty();
		
		// load configuration information (template directories etc.)
		require_once($conf);
		
		// create a class property from the smarty object
		$this->smarty = &$smarty;
	}
}

/**
 * Load HTML_QuickForm2
 *
 * Creates new HTML_QuickForm2 object and returns it. For further
 * details see http://pear.php.net/manual/en/package.html.html-quickform2.tutorial.php
 * 
 * @param string Form's name
 * @param string Form's method
 * @param mixed Extra attributes for <form> tag
 * @param bool Whether to track if the form was submitted by adding
 * a special hidden field. If the name of such field is not present
 * in the $_GET or $_POST values, the form will be considered as not
 * submitted.
 *
 * @return object Instance of HTML_QuickForm
 */
public function loadQuickForm ($form_name = null, $method = 'post', 
				$attributes = array('accept-charset' => 'utf-8'), $track_submit = false)
{
	require_once('HTML/QuickForm2.php');
	return new HTML_QuickForm2($form_name, $method, $attributes, $track_submit);
}

/**
 * Load new HTML_QuickForm2 Smarty Renderer
 * 
 * http://pear.php.net/pepr/pepr-proposal-show.php?id=653
 * Register new renderer and creates new instance of
 * HTML_QuickForm_Renderer_Smarty using the current
 * instance of smarty. If Smarty is not loaded, a
 * Base_UtilityException will be thrown.
 * 
 * @return object Instance of HTML_QuickForm_Renderer_Smarty
 */
public function loadQuickFormSmartyRenderer()
{
	// make sure that smarty is loaded
	if (!($this->smarty instanceof Smarty)) {
		throw new Base_UtilityException('Smarty is not loaded');
	}
	
	// load the QuickForm2 Renderer
	require_once('HTML/QuickForm2/Renderer.php');
	
	// register new renderer
	HTML_QuickForm2_Renderer::register('smarty', 'HTML_QuickForm2_Renderer_Smarty');
	$renderer = HTML_QuickForm2_Renderer::factory('smarty');
		
	// trigger compat mode		
	$renderer->setOption('old_compat', true);
	
	// get base instance
	$BASE = load('base:base');
	
	// grouping errors to be shown above the form
	$renderer->setOption('group_errors', (bool)$BASE->_conf['forms']['group_errors']);
	
	// redefine require note option
	$renderer->setOption('required_note', '<p class="required_note">* '.gettext('Required fields').'</p>');
	
	return $renderer;
}

/**
 * Interface to PEAR::Date
 * 
 * Takes method name as first argument, the method params
 * as second argument. If the third argument is omitted, the
 * actual date/time will be assumed.
 * 
 * For a full list of methods and params see
 * http://pear.php.net/package/Date/docs/latest/Date/Date.html.
 * 
 * $time can be an ISO 8601, TIMESTAMP or UNIXTIME date/time.
 *
 * Every date passed or generated by PEAR::Date will
 * be converted in the timezone defined by
 * base::_defaults['environment']['timezone']. If 
 * base::_defaults['environment']['timezone'] isn't set, empty
 * or contains an unconfigured value, the dates will be
 * converted to UTC.
 * 
 * If you don't like to get a date/time converted to the
 * the configured time zone, use PEAR::Date directly
 * 
 * @throws Base_UtilityException
 * @param string Method name
 * @param array Method params
 * @param string Date/time
 * @return string Date/time
 */
public function time ($method, $params, $date = null)
{
	// load PEAR::Date
	require_once('Date.php');
	require_once('Date/TimeZone.php');
	
	if (!($this->date instanceof Date) || !($this->timezone instanceof Date_TimeZone)) {
		// prepare timezone
		if (empty($this->_defaults['environment']['timezone'])) {
			$timezone = 'UTC';
		} else {
			$timezone = $this->_defaults['environment']['timezone'];
		}
		
		// initialize PEAR::Date
		$this->date = new Date();
		$this->timezone = new Date_Timezone($timezone);
	}
	
	// prepare PEAR::Date for new operation
	if (empty($date)) {
		$date = mktime();	
	}
	$this->date->setDate($date);
	$this->date->converttz($this->timezone);
	
	// execute requested method
	if (!is_callable(array($this->date, $method), false)) {
		throw new Base_UtilityException('Requested method is not callable');
	} else {
		return call_user_func_array(array($this->date, $method), $params);
	}
}

// End of class
}

class Base_UtilityException extends Exception { }

?>