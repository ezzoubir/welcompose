<?php

/**
 * Project: Base Classes
 * File: utility.class.php
 * 
 * Copyright (c) 2004 - 2006 sopic GmbH
 * 
 * Project owner:
 * sopic GmbH
 * 8472 Seuzach, Switzerland
 * http://www.sopic.com/
 *
 * This file is licensed under the terms of the GNU Lesser
 * General Public License
 * http://opensource.org/licenses/lgpl-license.php
 * 
 * $Id: utility.class.php 48 2007-01-19 15:49:28Z andreas $
 * 
 * @copyright 2004 - 2006 sopic GmbH
 * @author Andreas Ahlenstorf
 * @package Base
 * @version php5.1-1.0
 * @license http://opensource.org/licenses/lgpl-license.php GNU Lesser General Public License
 */

class Base_Utility {

	/**
	 * Reference to Smarty
	 *
	 * @var object
	 */
	public $smarty = null;
	
	/**
	 * Reference to PEAR::Date object
	 * 
	 * @var object
	 */
	public $date = null;
	
	/**
	 * Reference to PEAR::Date_Timezone object
	 * 
	 * @var object
	 */
	public $timezone = null;

/**
 * Smarty Import Function
 *
 * Function to import Smarty into the base class. This function
 * takes the full path to a smarty config file as first argument.
 * The config file should look (more or less) like Example 2-9 in 
 * the Smarty documentation:
 *
 * http://smarty.php.net/manual/en/installing.smarty.basic.php
 *
 * @param string Path to smarty configuration file
 */
public function loadSmarty ($conf)
{
	// input check
	if (empty($conf) || !is_scalar($conf)) {
		trigger_error("No path to Smarty configuration file supplied", E_USER_ERROR);
	}
	$conf = Base_Compat::fixDirectorySeparator($conf);
	if (!file_exists($conf) || !is_readable($conf)) {
		trigger_error("Smarty configuration file $conf not found", E_USER_ERROR);
	}	
	// load smarty class
	$file = dirname(__FILE__).'/../smarty/Smarty.class.php';
	$file = Base_Compat::fixDirectorySeparator($file);
	require_once($file);

	// create new smarty instance if none exists
	if (!($this->smarty instanceof Smarty)) {
		
		// create new smarty instance
		$smarty = new Smarty();
		
		// load configuration information (template directories etc.)
		require_once($conf);
		
		// create a class property from the smarty object
		$this->smarty = &$smarty;
	}
}

/**
 * Load HTML_QuickForm
 *
 * Creates new HTML_QuickForm object and returns it. For further
 * details see http://pear.php.net/manual/en/package.html.html-quickform.html-quickform.html-quickform.php
 * 
 * @param string Form's name
 * @param string Form's method
 * @param string Form's target
 * @param mixed Extra attributes for <form> tag
 * @param bool Whether to track if the form was submitted by adding
 * a special hidden field. If the name of such field is not present
 * in the $_GET or $_POST values, the form will be considered as not
 * submitted.
 *
 * @return object Instance of HTML_QuickForm
 */
public function loadQuickForm ($form_name = null, $method = 'post',
	$action = null, $target = '_self', $attributes = null, $track_submit = false)
{
	require_once('HTML/QuickForm.php');
	return new HTML_QuickForm($form_name, $method, $action, $target, $attributes, $track_submit);
}

/**
 * Load new HTML_QuickForm Smarty Renderer
 * 
 * Creates new instance of HTML_QuickForm_Renderer_ArraySmarty using
 * the current instance of smarty. If Smarty is not loaded, a
 * Base_UtilityException will be thrown.
 * 
 * @return object Instance of HTML_QuickForm_Renderer_ArraySmarty
 */
public function loadQuickFormSmartyRenderer()
{
	// make sure that smarty is loaded
	if (!($this->smarty instanceof Smarty)) {
		throw new Base_UtilityException('Smarty is not loaded');
	}
	
	// return new smarty renderer
	require_once('HTML/QuickForm/Renderer/ArraySmarty.php');
	return new HTML_QuickForm_Renderer_ArraySmarty($this->smarty);	
}

/**
 * Interface to PEAR::Date
 * 
 * Takes method name as first argument, the method params
 * as second argument. If the third argument is omitted, the
 * actual date/time will be assumed.
 * 
 * For a full list of methods and params see
 * http://pear.php.net/package/Date/docs/latest/Date/Date.html.
 * 
 * $time can be an ISO 8601, TIMESTAMP or UNIXTIME date/time.
 *
 * Every date passed or generated by PEAR::Date will
 * be converted in the timezone defined by
 * base::_defaults['environment']['timezone']. If 
 * base::_defaults['environment']['timezone'] isn't set, empty
 * or contains an unconfigured value, the dates will be
 * converted to UTC.
 * 
 * If you don't like to get a date/time converted to the
 * the configured time zone, use PEAR::Date directly
 * 
 * @throws Base_UtilityException
 * @param string Method name
 * @param array Method params
 * @param string Date/time
 * @return string Date/time
 */
public function time ($method, $params, $date = null)
{
	// load PEAR::Date
	require_once('Date.php');
	require_once('Date/TimeZone.php');
	
	if (!($this->date instanceof Date) || !($this->timezone instanceof Date_TimeZone)) {
		// prepare timezone
		if (empty($this->_defaults['environment']['timezone'])) {
			$timezone = 'UTC';
		} else {
			$timezone = $this->_defaults['environment']['timezone'];
		}
		
		// initialize PEAR::Date
		$this->date = new Date();
		$this->timezone = new Date_Timezone($timezone);
	}
	
	// prepare PEAR::Date for new operation
	if (empty($date)) {
		$date = mktime();	
	}
	$this->date->setDate($date);
	$this->date->converttz($this->timezone);
	
	// execute requested method
	if (!is_callable(array($this->date, $method), false)) {
		throw new Base_UtilityException('Requested method is not callable');
	} else {
		return call_user_func_array(array($this->date, $method), $params);
	}
}

// End of class
}

class Base_UtilityException extends Exception { }

?>